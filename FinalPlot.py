from project1 import library
from project1 import IOfunctions
import numpy as np
import pickle 
import matplotlib.pyplot as plt

if __name__ == '__main__':
    F_MoleculesDescriptor = 'MoleculesDescriptor.'
    F_Train = 'Training Set.x'
    F_Test = 'Test Set.x'
    F_ga_structure = 'GA_structure.dat'
    F_Filter = 'Filter.dat'
    nIntervals = 200
# load intervals generated by Filter data.py
    f = open(F_Filter, "rb")
    Filter = pickle.load(f)
    f.close()
# load GA structure
    f = open(F_ga_structure, "rb")
    ga = pickle.load(f)
    f.close()            
    results = IOfunctions.ReadFeatures(F_Nonlinear='Distances.csv', F_linear_Train='LinearFeaturesTrain.csv',\
        F_Response_Train='ResponseTrain.csv', F_linear_Test='LinearFeaturesTest.csv',\
        F_Response_Test='ResponseTest.csv', F_NonlinearFeatures='NonlinearFeatures.dat',\
        F_FeaturesAll='LinearFeaturesAll.dat', F_FeaturesReduced='LinearFeaturesReduced.dat',\
        F_System='system.dat', F_Records=None, verbose=False)
    Intervals = Filter['Intervals']   
    FeaturesAll = results['Linear Features All']
    FeaturesReduced = results['Linear Features Reduced']
    MoleculePrototypes = IOfunctions.ReadMoleculeDescription(F=F_MoleculesDescriptor)
    RecordsTest = IOfunctions.ReadRecords(F_Test, MoleculePrototypes)
    if RecordsTest[0].nMolecules == 2:
        R = 'R_Average'
    else:
        R = 'R_CenterOfMass_Average'
    E = []
    N = []
    for m in range(0, len(ga.DecreasingChromosomes), 1):
#   for m in range(0, 2, 1):
        chromosome = ga.DecreasingChromosomes[m]
        RMax = 0
        RMin = 100
        for i in range(0, len(RecordsTest), 1):
            RecordsTest[i].get_energy(chromosome, FeaturesAll, FeaturesReduced)
            if R == 'R_Average':
                if RMax < RecordsTest[i].R_Average:
                    RMax = RecordsTest[i].R_Average
                if RMin > RecordsTest[i].R_Average:
                    RMin = RecordsTest[i].R_Average                
            elif R == 'R_CenterOfMass_Average':
                if RMax < RecordsTest[i].R_CenterOfMass_Average:
                    RMax = RecordsTest[i].R_CenterOfMass_Average
                if RMin > RecordsTest[i].R_CenterOfMass_Average:
                    RMin = RecordsTest[i].R_CenterOfMass_Average
            if (i % 1000 == 0):
                print('Record number = ', i)
        Increment = (RMax - RMin) / nIntervals
        XIntervals = []
        for i in range(0, nIntervals, 1):
            xMin = i * Increment + RMin
            xMax = i * Increment + Increment + RMin
            XIntervals.append((xMin, xMax))
        
        n = np.zeros(shape=(nIntervals), dtype=float) # n[i] = number of observations in interval    
        mSE = np.zeros(shape=(nIntervals), dtype=float) # MSE[i] = cumulative MSE in interval
        rMSE = np.zeros(shape=(nIntervals), dtype=float) # error in interval = sqrt(MSE[i] / n[i])
        E_True = np.zeros(shape=(nIntervals), dtype=float) # n[i] = number of observations in interval    
        E_Predicted = np.zeros(shape=(nIntervals), dtype=float) # n[i] = number of observations in interval    
        XPlot = np.zeros(shape=(nIntervals), dtype=float)
        n = list(n)
        mSE = list(mSE)
        rMSE = list(rMSE)
        E_True = list(E_True)
        E_Predicted = list(E_Predicted)
        XPlot = list(XPlot)
        for i in range(0, nIntervals, 1):
            XPlot[i] = (XIntervals[i][1] + XIntervals[i][0])/2
        for i in range(0, len(RecordsTest), 1):
            for j in range(0, nIntervals, 1):
                if R == 'R_Average':
                    if (RecordsTest[i].R_Average > XIntervals[j][0]) and (RecordsTest[i].R_Average < XIntervals[j][1]):
                        mSE[j] += RecordsTest[i].MSE
                        E_True[j] += RecordsTest[i].E_True
                        E_Predicted[j] += RecordsTest[i].E_Predicted
                        n[j] += 1
                        break
                elif R == 'R_CenterOfMass_Average':
                    if (RecordsTest[i].R_CenterOfMass_Average > XIntervals[j][0]) and (RecordsTest[i].R_CenterOfMass_Average < XIntervals[j][1]):
                        mSE[j] += RecordsTest[i].MSE
                        E_True[j] += RecordsTest[i].E_True
                        E_Predicted[j] += RecordsTest[i].E_Predicted
                        n[j] += 1
                        break                    
        j = 0 # remove intervals with no points
        while j < len(n):
            if n[j] == 0:
                del(n[j])
                del(mSE[j])
                del(rMSE[j])
                del(E_True[j])
                del(E_Predicted[j])
                del(XPlot[j])
                continue
            rMSE[j] = np.sqrt(mSE[j] / n[j])
            E_True[j] = E_True[j] / n[j]
            E_Predicted[j] = E_Predicted[j] / n[j]
            j += 1
        X_Plot_Train = [] # X axis
        X_Plot_Test = []
        rMSE_Plot_Train = [] # Y axis
        rMSE_Plot_Test = []
        E_True_Plot_Train = []
        E_True_Plot_Test = []
        E_Predicted_Plot_Train = []
        E_Predicted_Plot_Test = []
        for i in range(0, len(XPlot), 1):
            if library.InInterval(XPlot[i], Intervals) != -1: # plot as trained points
                X_Plot_Train.append(XPlot[i])
                rMSE_Plot_Train.append(rMSE[i])
                E_True_Plot_Train.append(E_True[i])
                E_Predicted_Plot_Train.append(E_Predicted[i])
            else:
                X_Plot_Test.append(XPlot[i])
                rMSE_Plot_Test.append(rMSE[i])
                E_True_Plot_Test.append(E_True[i])
                E_Predicted_Plot_Test.append(E_Predicted[i])
        
        E.append(E_True)
        N.append(n)
# plot RMSE          
        XMin = RMin - (RMax-RMin) * 0.02
        XMax = RMax + (RMax-RMin) * 0.02
        EMin = min(min(rMSE_Plot_Train), min(rMSE_Plot_Test))
        EMax = max(max(rMSE_Plot_Train), max(rMSE_Plot_Test))
        YMin = EMin - (EMax-EMin) * 0.02
        YMax = EMax + (EMax-EMin) * 0.02
        fig1 = plt.figure(1, figsize=(19,10))
        plt.xlim((XMin, XMax))
        plt.ylim((YMin, YMax))
        plt.scatter(X_Plot_Train, rMSE_Plot_Train, c='red', marker='.', label='Trained region')
        plt.scatter(X_Plot_Test, rMSE_Plot_Test, c='blue', marker='.', label='Not trained region')
        plt.legend()
        plt.ylabel('RMSE')
        plt.xlabel('Average distance between centers of masses of molecules')
        plt.title('RMSE vs. average distance')
        plt.show(fig1)
        F = "RMSE. Number of predictors = " + str(chromosome.Size) + ".png"
        plt.savefig(F, bbox_inches='tight')
        plt.close(fig1)
# plot Energy
        EMin = min(min(E_True_Plot_Train), min(E_True_Plot_Test), min(E_Predicted_Plot_Train), min(E_Predicted_Plot_Test))
        EMax = max(max(E_True_Plot_Train), max(E_True_Plot_Test), max(E_Predicted_Plot_Train), max(E_Predicted_Plot_Test))
        YMin = EMin - (EMax-EMin) * 0.02
        YMax = EMax + (EMax-EMin) * 0.02
        fig2 = plt.figure(2, figsize=(19,10))
        plt.xlim((XMin, XMax))
        plt.ylim((YMin, YMax))
        plt.plot(X_Plot_Train, E_True_Plot_Train, c='red', marker='.', label='True Energy. Trained region')
        plt.plot(X_Plot_Test, E_True_Plot_Test, c='blue', marker='.', label='True Energy. Not trained region')
        plt.scatter(X_Plot_Train, E_Predicted_Plot_Train, c='green', marker='.', label='Predicted Energy. Trained region')
        plt.scatter(X_Plot_Test, E_Predicted_Plot_Test, c='violet', marker='.', label='Predicted Energy. Not trained region')
        plt.legend()
        plt.ylabel('Energy')
        plt.xlabel('Average distance between centers of masses of molecules')
        plt.title('Energy vs. average distance')
        plt.show(fig2)
        F = "Energy. Number of predictors = " + str(chromosome.Size) + ".png"
        plt.savefig(F, bbox_inches='tight')
        plt.close(fig2)

